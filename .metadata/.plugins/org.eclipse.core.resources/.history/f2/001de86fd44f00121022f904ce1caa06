package com.vestrel00.nekko;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.utils.TimeUtils;
import com.vestrel00.nekko.extras.StringTyper;
import com.vestrel00.nekko.interf.Drawable;
import com.vestrel00.nekko.interf.Touchable;
import com.vestrel00.nekko.interf.Updatable;

public class Instructions implements Updatable, Drawable, Touchable {
	
	private final CharSequence[] INSTRUCTIONS = {
			"This is your health.\nThe less red it is, the less health you have."
	}

	private Color color;
	private StringTyper typer;
	private float[] widths, heights;
	private int phase = 0, index = 0;
	private long phaseEndTime;

	public Instructions() {
		color = new Color(Color.CLEAR);
		typer = new StringTyper(INSTRUCTIONS[index], 100000000L);
		widths = new float[INSTRUCTIONS.length];
		for (int i = 0; i < widths.length; i++){
			TextBounds bounds = KFNekko.resource.chunkFive.getBounds(INSTRUCTIONS[i]);
			widths[i] = KFNekko.resource.chunkFive.getBounds(INSTRUCTIONS[i]).width;
		}
	}

	@Override
	public void draw(SpriteBatch batch) {
		// draw author
		KFNekko.resource.chunkFive.setColor(1.0f, 1.0f, 1.0f, color.a);
		KFNekko.resource.chunkFive.draw(batch, authorTyper.getTypedStr(),
				KFNekko.camera.camera.position.x - authorWidths[index] * 0.5f,
				KFNekko.settings.viewHeight - 7.0f);
		// draw link
		KFNekko.resource.arial.setColor(0.0f, 0.0f, 0.0f, color.a);
		KFNekko.resource.arial.setScale(1.2f);
		KFNekko.resource.arial.draw(batch, linkTyper.getTypedStr(), 20.0f,
				40.0f);
		// draw works
		KFNekko.resource.arial.drawMultiLine(batch, workTyper.getTypedStr(),
				20.0f, 260.0f);
	}

	@Override
	public void update() {
		authorTyper.update();
		linkTyper.update();
		workTyper.update();
		switch (phase) {
		case 0:
		case 1:
			updateColor(0.03f);
			break;
		case 2:
			if (updateColor(0.04f)) {
				phase = 0;
				if (++index == authors.length)
					index = 0;
				authorTyper.reset(authors[index]);
				linkTyper.reset(links[index]);
				workTyper.reset(works[index]);
			}
			break;
		}
	}

	private boolean updateColor(float colorSpeed) {
		switch (phase) {
		case 0:
			color.r += colorSpeed;
			color.g += colorSpeed;
			color.b += colorSpeed;
			color.a += colorSpeed;
			if (color.a > 1.0f) {
				phaseEndTime = TimeUtils.nanoTime();
				phase = 1;
				color.r = 1.0f;
				color.g = 1.0f;
				color.b = 1.0f;
				color.a = 1.0f;
				return true;
			}
			break;
		case 1:
			if (TimeUtils.nanoTime() - phaseEndTime > 2000000000L) {
				phaseEndTime = TimeUtils.nanoTime();
				phase = 2;
				return true;
			}
			break;
		case 2:
			color.a -= 0.03f;
			if (color.a < 0.0f) {
				color.set(Color.CLEAR);
				return true;
			}
			break;
		}
		return false;
	}

	@Override
	public boolean onTouchDown(float x, float y) {
		// TODO Auto-generated method stub
		return false;
	}

}
