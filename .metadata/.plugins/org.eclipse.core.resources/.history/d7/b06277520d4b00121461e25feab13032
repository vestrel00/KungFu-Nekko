package com.vestrel00.nekko.ui.components;

import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.TimeUtils;
import com.vestrel00.nekko.actors.states.CombatState;

/**
 * <p>
 * Detects combos based on collected user input.
 * </p>
 * 
 * <p>
 * <b>Nekko Combo sheet</b>
 * </p>
 * 
 * <ul>
 * <b> Spin</b>
 * <li>down + jump + attack</li>
 * </ul>
 * 
 * <ul>
 * <b> Power Shot</b>
 * <li>down + right + right + attack or</li>
 * <li>down + left + left + attack</li>
 * </ul>
 * 
 * <ul>
 * <b> Flying Kick</b>
 * <li>down + right + jump + attack or</li>
 * <li>down + left + jump + attack</li>
 * </ul>
 * 
 * <ul>
 * <b> Super Uppercut</b>
 * <li>down + down + up + attack</li>
 * </ul>
 * 
 * <ul>
 * <b> One Two Combo</b>
 * <li>down + right + attack or</li>
 * <li>down + left + attack</li>
 * </ul>
 * 
 * <ul>
 * <b> Low-Middle Kick</b>
 * <li>down + down + attack</li>
 * </ul>
 * 
 * <ul>
 * <b> High Kick</b>
 * <li>down + up + up + attack</li>
 * </ul>
 * 
 * <ul>
 * <b> Downward Kick</b>
 * <li>down + attack</li>
 * </ul>
 * 
 * <ul>
 * <b> Two-Sided Attack</b>
 * <li>down + up + left + right + attack or</li>
 * <li>down + up + right + left + attack</li>
 * </ul>
 * 
 * <ul>
 * <b>Round Kick</b>
 * <li>down + left + right + attack or</li>
 * <li>down + right + left + attack</li>
 * </ul>
 * 
 * <ul>
 * <b>Uppercut</b>
 * <li>down + up + attack</li>
 * </ul>
 * 
 * @author Estrellado, Vandolf
 * 
 */
public class ComboAttackManager {

	public static final int INPUT_LEFT = 0, INPUT_RIGHT = 1, INPUT_UP = 2,
			INPUT_DOWN = 3, INPUT_ATTACK = 4, INPUT_JUMP = 5;
	private static final long RESET_DELAY = 800000000L;

	private Array<Integer> history;
	private long lastInputTime;

	public ComboAttackManager() {
		history = new Array<Integer>();
	}

	/**
	 * This will determine the combatState that it will return based on the
	 * input concatenated with the history.
	 */
	public CombatState input(int input) {
		// reset history if input past the recording time
		if (TimeUtils.nanoTime() - lastInputTime > RESET_DELAY
				&& history.size > 0)
			history.clear();

		// wait for INPUT_DOWN to start recording history
		if (history.size == 0 && input != INPUT_DOWN)
			// regular attack
			return (input == INPUT_ATTACK) ? CombatState.FASTSHOT
					: CombatState.IDLE;

		lastInputTime = TimeUtils.nanoTime();
		history.add(input);
		if (input == INPUT_ATTACK) {
			CombatState state = recognize();
			history.clear();
			return state;
		} else
			return CombatState.IDLE;

	}

	private CombatState recognize() {
		switch (history.size) {
		case 2:
			return CombatState.DOWNWARDKICK;
		case 3:
			return recognize3();
		default:
			return CombatState.FASTSHOT;
		}
	}

	/**
	 * Receiving down + ? + attack
	 */
	private CombatState recognize3() {
		switch(history.get(1)){
		case INPUT_JUMP:
			return CombatState.SPIN;
		case INPUT_LEFT:
		case INPUT_RIGHT:
			return CombatState.ONETWOCOMBO;
		case INPUT_DOWN:
			return CombatState.LOWMIDDLEKICK;
		}
		return null;
	}
}
