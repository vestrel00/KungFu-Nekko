package com.vestrel00.nekko.ui.components;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas.AtlasRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.Array;
import com.vestrel00.nekko.KFNekko;
import com.vestrel00.nekko.actors.Nekko;
import com.vestrel00.nekko.interf.HUDUI;

public class HUDSimple implements HUDUI {

	private Array<Rectangle> baseRects, rects;
	private Array<AtlasRegion> regions;
	// screen rectangles
	private Rectangle attack1Base, attack2Base, attack3Base, attack4Base,
			pauseBase, optionsBase, topLeftBase, topRightBase;
	// scene rectangles
	private Rectangle attack1, attack2, attack3, attack4, pause, options,
			topLeft, topRight;
	private AtlasRegion topRightRegion, topLeftRegion, attack1Region,
			attack2Region, attack3Region, attack4Region, pauseRegion,
			optionsRegion;

	private Nekko player;
	private HUDInputProcessor processor;

	public HUDSimple(Nekko player, HUDInputProcessor processor) {
		this.player = player;
		this.processor = processor;
		initRegions();
		initRects();
	}

	private void initRegions() {
		topLeftRegion = KFNekko.resource.atlas.findRegion("topLeftCorner");
		topRightRegion = KFNekko.resource.atlas.findRegion("topRightCorner");
		attack1Region = KFNekko.resource.atlas.findRegion("jump");
		attack2Region = KFNekko.resource.atlas.findRegion("attack");
		attack3Region = KFNekko.resource.atlas.findRegion("attack");
		attack4Region = KFNekko.resource.atlas.findRegion("jump");
		pauseRegion = KFNekko.resource.atlas.findRegion("pause");
		optionsRegion = KFNekko.resource.atlas.findRegion("options");

		regions = new Array<AtlasRegion>();
		regions.add(topLeftRegion);
		regions.add(topRightRegion);
		regions.add(attack1Region);
		regions.add(attack2Region);
		regions.add(attack3Region);
		regions.add(attack4Region);
		regions.add(pauseRegion);
		regions.add(optionsRegion);

	}

	private void initRects() {
		// SCREEN RECTS
		topLeftBase = new Rectangle(8.0f, 264.0f,
				(float) topLeftRegion.originalWidth,
				(float) topLeftRegion.originalHeight);
		topRightBase = new Rectangle(361.0f, 264.0f,
				(float) topRightRegion.originalWidth,
				(float) topRightRegion.originalHeight);
		attack1Base = new Rectangle(36.0f, 9.0f,
				(float) attack1Region.originalWidth,
				(float) attack1Region.originalHeight);
		attack2Base = new Rectangle(104.0f, 9.0f,
				(float) attack2Region.originalWidth,
				(float) attack2Region.originalHeight);
		attack3Base = new Rectangle(396.0f, 9.0f,
				(float) attack3Region.originalWidth,
				(float) attack3Region.originalHeight);
		attack4Base = new Rectangle(328.0f, 9.0f,
				(float) attack4Region.originalWidth,
				(float) attack4Region.originalHeight);
		pauseBase = new Rectangle(252.0f, 13.0f,
				(float) pauseRegion.originalWidth,
				(float) pauseRegion.originalHeight);
		optionsBase = new Rectangle(183.0f, 13.0f,
				(float) optionsRegion.originalWidth,
				(float) optionsRegion.originalHeight);

		baseRects = new Array<Rectangle>();
		baseRects.add(topLeftBase);
		baseRects.add(topRightBase);
		baseRects.add(attack1Base);
		baseRects.add(attack2Base);
		baseRects.add(attack3Base);
		baseRects.add(attack4Base);
		baseRects.add(pauseBase);
		baseRects.add(optionsBase);
		// ///

		// SCENE
		topLeft = new Rectangle(topLeftBase);
		topRight = new Rectangle(topRightBase);
		attack1 = new Rectangle(attack1Base);
		attack2 = new Rectangle(attack2Base);
		attack3 = new Rectangle(attack3Base);
		attack4 = new Rectangle(attack4Base);
		pause = new Rectangle(pauseBase);
		options = new Rectangle(optionsBase);

		rects = new Array<Rectangle>();
		rects.add(topLeft);
		rects.add(topRight);
		rects.add(attack1);
		rects.add(attack2);
		rects.add(attack3);
		rects.add(attack4);
		rects.add(pause);
		rects.add(options);

	}

	@Override
	public void draw(SpriteBatch batch) {
		batch.setColor(Color.WHITE);
		for (int i = 0; i < rects.size; i++)
			batch.draw(regions.get(i), rects.get(i).x, rects.get(i).y,
					rects.get(i).width, rects.get(i).height);
		batch.setColor(KFNekko.worldColor);
	}

	@Override
	public void update() {
		// update scene rectangles
		for (int i = 0; i < rects.size; i++) {
			rects.get(i).x = baseRects.get(i).x + KFNekko.camera.rect.x;
			rects.get(i).y = baseRects.get(i).y + KFNekko.camera.rect.y;
		}
	}

	@Override
	public boolean onTouchDown(float x, float y) {
		if (left.contains(x, y)) {
			processor.attackManager.input(ComboAttackManager.INPUT_LEFT);
			return true;
		} else if (right.contains(x, y)) {
			processor.attackManager.input(ComboAttackManager.INPUT_RIGHT);
			return true;
		} else if (up.contains(x, y)) {
			processor.attackManager.input(ComboAttackManager.INPUT_UP);
			return true;
		} else if (down.contains(x, y)) {
			processor.attackManager.input(ComboAttackManager.INPUT_DOWN);
			return true;
		} else if (jump.contains(x, y)) {
			processor.attackManager.input(ComboAttackManager.INPUT_JUMP);
			player.jump();
			return true;
		} else if (attack.contains(x, y)) {
			player.setCombatState(processor.attackManager
					.input(ComboAttackManager.INPUT_ATTACK));
			return true;
		} else
			return false;
	}
}
