package com.vestrel00.nekko;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.TimeUtils;
import com.vestrel00.nekko.extras.StringTyper;
import com.vestrel00.nekko.interf.Drawable;
import com.vestrel00.nekko.interf.Touchable;
import com.vestrel00.nekko.interf.Updatable;

public class Instructions implements Updatable, Drawable, Touchable {

	private enum Widgets {
		BEGIN, HEALTH, STAMINA, PAUSE, OPTIONS, ATTACK, JUMP;
	}

	private final CharSequence[] instructionTitles = {
			"Touch a widget for instruction", "Health", "Stamina", "Pause",
			"Options", "Attack Buttons", "Jump" };

	private final CharSequence[] instructionTexts = {};

	private Widgets currentWidget;
	private Color color;
	private StringTyper textTyper, titleTyper;
	private float[] widths, heights;
	private Rectangle[] instructionRects;
	private int phase = 0, instructionIndex;
	private long phaseEndTime;

	public Instructions() {
		widths = new float[instructionTitles.length];
		heights = new float[instructionTitles.length];
		for (int i = 0; i < instructionTitles.length; i++) {
			TextBounds bounds = KFNekko.resource.chunkFive
					.getBounds(instructionTexts[i]);
			widths[i] = bounds.width;
			heights[i] = bounds.height
					+ KFNekko.resource.chunkFive
							.getBounds(instructionTitles[i]).height;
		}
		currentWidget = Widgets.BEGIN;
		setInstructionIndex();
		color = new Color(Color.CLEAR);
		textTyper = new StringTyper(instructionTitles[instructionIndex],
				100000000L);
		titleTyper = new StringTyper(instructionTitles[instructionIndex],
				10000000L);

		// init instruction rectangles
		instructionRects = new Rectangle[instructionTitles.length];
		instructionRects[0] = new Rectangle(KFNekko.settings.viewWidthHalf
				- widths[0] * 0.5f, KFNekko.settings.viewHeightHalf
				- heights[0] * 0.5f, widths[0], heights[0]);
	}

	private void setInstructionIndex() {
		switch (currentWidget) {
		case BEGIN:
			instructionIndex = 0;
			break;
		case HEALTH:
			instructionIndex = 1;
			break;
		case STAMINA:
			instructionIndex = 2;
			break;
		case PAUSE:
			instructionIndex = 3;
			break;
		case OPTIONS:
			instructionIndex = 4;
			break;
		case ATTACK:
			instructionIndex = 5;
			break;
		case JUMP:
			instructionIndex = 6;
			break;
		}
	}

	@Override
	public void draw(SpriteBatch batch) {
		batch.end();
		// draw rectangle
		KFNekko.hud.shape.begin(ShapeType.FilledRectangle);
		KFNekko.hud.shape.setColor(color);
		// KFNekko.hud.shape.filledRect(textRects[x, y, width, height) TODO
		KFNekko.hud.shape.end();

		// draw instruction title
		KFNekko.resource.chunkFive.setColor(1.0f, 1.0f, 1.0f, color.a);
		KFNekko.resource.chunkFive.draw(batch, titleTyper.getTypedStr(),
				KFNekko.camera.rect.x + instructionRects[instructionIndex].x,
				KFNekko.camera.rect.y + instructionRects[instructionIndex].y
						+ instructionRects[instructionIndex].height);
		// draw instruction text
		KFNekko.resource.arial.setColor(0.0f, 0.0f, 0.0f, color.a);
		KFNekko.resource.arial.setScale(1.2f);
		KFNekko.resource.arial.drawMultiLine(batch, textTyper.getTypedStr(),
				20.0f, 260.0f);

	}

	@Override
	public void update() {
		authorTyper.update();
		linkTyper.update();
		workTyper.update();
		switch (phase) {
		case 0:
		case 1:
			updateColor(0.03f);
			break;
		case 2:
			if (updateColor(0.04f)) {
				phase = 0;
				if (++index == authors.length)
					index = 0;
				authorTyper.reset(authors[index]);
				linkTyper.reset(links[index]);
				workTyper.reset(works[index]);
			}
			break;
		}
	}

	private boolean updateColor(float colorSpeed) {
		switch (phase) {
		case 0:
			color.r += colorSpeed;
			color.g += colorSpeed;
			color.b += colorSpeed;
			color.a += colorSpeed;
			if (color.a > 1.0f) {
				phaseEndTime = TimeUtils.nanoTime();
				phase = 1;
				color.r = 1.0f;
				color.g = 1.0f;
				color.b = 1.0f;
				color.a = 1.0f;
				return true;
			}
			break;
		case 1:
			if (TimeUtils.nanoTime() - phaseEndTime > 2000000000L) {
				phaseEndTime = TimeUtils.nanoTime();
				phase = 2;
				return true;
			}
			break;
		case 2:
			color.a -= 0.03f;
			if (color.a < 0.0f) {
				color.set(Color.CLEAR);
				return true;
			}
			break;
		}
		return false;
	}

	@Override
	public boolean onTouchDown(float x, float y) {
		// TODO Auto-generated method stub
		return false;
	}

}
