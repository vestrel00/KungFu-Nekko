package com.vestrel00.nekko;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.Array;
import com.vestrel00.nekko.extras.StringTyper;
import com.vestrel00.nekko.interf.Drawable;
import com.vestrel00.nekko.interf.Touchable;
import com.vestrel00.nekko.interf.Updatable;

public class Instructions implements Updatable, Drawable, Touchable {

	private enum Widgets {
		BEGIN, HEALTH, STAMINA, PAUSE, OPTIONS, ATTACK, JUMP;
	}

	private final CharSequence[] instructionTitles = {
			"Touch a widget for instruction", "Health", "Stamina", "Pause",
			"Options", "Attack Buttons", "Jump" };

	private final CharSequence[] instructionTexts = {
			"Touch something!",
			"The more red this is, the more health you have.\n" +
			"Once it turns completely gray, it is game over!\n" +
			"You can keep tapping this to regain 1 health for each tap.",
			"The more yellow this is, the more stamina you have!"
	};

	private Widgets currentWidget, nextWidget;
	private Color color;
	private StringTyper textTyper, titleTyper;
	private float[] widths, heights;
	private Rectangle[] instructionRects;
	private Array<Rectangle> widgetRects;
	private int phase = 0, instructionIndex;

	public Instructions() {
		widths = new float[instructionTitles.length];
		heights = new float[instructionTitles.length];
		for (int i = 0; i < instructionTitles.length; i++) {
			TextBounds bounds = KFNekko.resource.chunkFive
					.getBounds(instructionTexts[i]);
			widths[i] = bounds.width;
			heights[i] = bounds.height
					+ KFNekko.resource.chunkFive
							.getBounds(instructionTitles[i]).height;
		}
		currentWidget = Widgets.BEGIN;
		setInstructionIndex();
		color = new Color(Color.CLEAR);
		textTyper = new StringTyper(instructionTitles[instructionIndex],
				100000000L);
		titleTyper = new StringTyper(instructionTitles[instructionIndex],
				10000000L);

		// get widget rectangles
		widgetRects = KFNekko.hud.ui.getScreenRects();
		initInstructionRects();
	}

	/**
	 * HUDSimple rects.add(attack1); rects.add(attack2); rects.add(attack3);
	 * rects.add(attack4); rects.add(pause); rects.add(options);
	 * rects.add(topLeft); rects.add(topRight);
	 */
	private void initInstructionRects() {
		instructionRects = new Rectangle[instructionTitles.length];
		// BEGIN
		instructionRects[0] = new Rectangle(KFNekko.settings.viewWidthHalf
				- widths[0] * 0.5f, KFNekko.settings.viewHeightHalf
				- heights[0] * 0.5f, widths[0], heights[0]);
		// HEALTH
		instructionRects[1] = new Rectangle(widgetRects.get(6).x,
				widgetRects.get(6).y - heights[1], widths[1], heights[1]);
		// STAMINA
		instructionRects[2] = new Rectangle(widgetRects.get(7).x
				+ widgetRects.get(7).width - widths[2], widgetRects.get(7).y
				- heights[2], widths[2], heights[2]);
		// PAUSE
		instructionRects[3] = new Rectangle(
				(widgetRects.get(4).x + widgetRects.get(4).width) * 0.5f
						- widths[3] * 0.5f, widgetRects.get(4).y
						+ widgetRects.get(4).height + 8.0f, widths[3],
				heights[3]);
		// OPTIONS
		instructionRects[4] = new Rectangle(
				(widgetRects.get(5).x + widgetRects.get(5).width) * 0.5f
						- widths[4] * 0.5f, widgetRects.get(5).y
						+ widgetRects.get(5).height + 8.0f, widths[4],
				heights[4]);
		// ATTACKS
		instructionRects[5] = new Rectangle(KFNekko.settings.viewWidthHalf
				- widths[5] * 0.5f, KFNekko.settings.viewHeightHalf
				- heights[5] * 0.5f - 40.0f, widths[5], heights[5]);
		// JUMP
		instructionRects[6] = new Rectangle(KFNekko.settings.viewWidthHalf
				- widths[6] * 0.5f, KFNekko.settings.viewHeightHalf
				- heights[6] * 0.5f, widths[6], heights[6]);
	}

	private void setInstructionIndex() {
		switch (currentWidget) {
		case BEGIN:
			instructionIndex = 0;
			break;
		case HEALTH:
			instructionIndex = 1;
			break;
		case STAMINA:
			instructionIndex = 2;
			break;
		case PAUSE:
			instructionIndex = 3;
			break;
		case OPTIONS:
			instructionIndex = 4;
			break;
		case ATTACK:
			instructionIndex = 5;
			break;
		case JUMP:
			instructionIndex = 6;
			break;
		}
	}

	@Override
	public void draw(SpriteBatch batch) {
		batch.end();
		
		// draw the hud!
		KFNekko.hud.draw(batch);
		
		// draw rectangle
		KFNekko.hud.shape.begin(ShapeType.FilledRectangle);
		KFNekko.hud.shape.setColor(color);
		KFNekko.hud.shape.filledRect(instructionRects[instructionIndex].x,
				instructionRects[instructionIndex].y,
				instructionRects[instructionIndex].width,
				instructionRects[instructionIndex].height);
		KFNekko.hud.shape.end();

		batch.begin();
		// draw instruction title
		KFNekko.resource.chunkFive.setColor(1.0f, 1.0f, 1.0f, color.a);
		KFNekko.resource.chunkFive.draw(batch, titleTyper.getTypedStr(),
				KFNekko.camera.rect.x + instructionRects[instructionIndex].x
						+ 2.0f, KFNekko.camera.rect.y
						+ instructionRects[instructionIndex].y
						+ instructionRects[instructionIndex].height - 2.0f);
		// draw instruction text
		KFNekko.resource.arial.setColor(1.0f, 1.0f, 1.0f, color.a);
		KFNekko.resource.arial.setScale(1.2f);
		KFNekko.resource.arial.drawMultiLine(batch, textTyper.getTypedStr(),
				KFNekko.camera.rect.x + instructionRects[instructionIndex].x
						+ 2.0f, KFNekko.camera.rect.y
						+ instructionRects[instructionIndex].y
						+ instructionRects[instructionIndex].height - 2.0f);
	}

	@Override
	public void update() {
// update the hud
		KFNekko.hud.update();
		titleTyper.update();
		textTyper.update();
		updateColor(0.03f);
	}

	private boolean updateColor(float colorSpeed) {
		switch (phase) {
		case 0: // fade in
			if ((color.r += colorSpeed) > 0.4118f)
				color.r = 0.4118f;
			if ((color.g += colorSpeed) > 0.6157f)
				color.g = 0.6157f;
			if ((color.b += colorSpeed) > 1.0f)
				color.b = 1.0f;
			if ((color.a += colorSpeed) > 1.0f)
				color.a = 1.0f;
			break;
		case 1: // fade out
			color.a -= 0.03f;
			if (color.a < 0.0f) {
				phase = 0;
				currentWidget = nextWidget;
				setInstructionIndex();
				color.set(Color.CLEAR);
				return true;
			}
			break;
		}
		return false;
	}

	/**
	 * HUDSimple rects.add(attack1); rects.add(attack2); rects.add(attack3);
	 * rects.add(attack4); rects.add(pause); rects.add(options);
	 * rects.add(topLeft); rects.add(topRight);
	 */
	@Override
	public boolean onTouchDown(float x, float y) {
		if (widgetRects.get(0).contains(x, y)
				|| widgetRects.get(1).contains(x, y)
				|| widgetRects.get(2).contains(x, y)
				|| widgetRects.get(3).contains(x, y))
			nextWidget = Widgets.ATTACK;
		else if (widgetRects.get(4).contains(x, y))
			nextWidget = Widgets.PAUSE;
		else if (widgetRects.get(5).contains(x, y))
			nextWidget = Widgets.OPTIONS;
		else if (widgetRects.get(6).contains(x, y))
			nextWidget = Widgets.HEALTH;
		else if (widgetRects.get(7).contains(x, y))
			nextWidget = Widgets.STAMINA;
		else
			nextWidget = Widgets.JUMP;

		phase = 1; // fade out then in to next instruction
		KFNekko.audio.touch();
		return true;
	}

}
